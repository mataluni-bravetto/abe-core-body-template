/**
 * AiGuardian Chrome Extension - Security Vulnerability Audit
 *
 * This script performs a comprehensive security audit to identify
 * potential vulnerabilities in the Chrome extension.
 */

class SecurityVulnerabilityAudit {
  constructor() {
    this.vulnerabilities = [];
    this.securityIssues = [];
    this.recommendations = [];
    this.auditResults = [];
  }

  /**
   * Run comprehensive security audit
   */
  async runSecurityAudit() {
    console.log('ðŸ”’ Starting Security Vulnerability Audit');
    console.log('='.repeat(60));

    const audits = [
      { name: 'XSS Vulnerability Scan', fn: this.auditXSSVulnerabilities },
      { name: 'Injection Attack Prevention', fn: this.auditInjectionAttacks },
      { name: 'Data Exposure Analysis', fn: this.auditDataExposure },
      { name: 'Permission Abuse Check', fn: this.auditPermissionAbuse },
      { name: 'Network Security Audit', fn: this.auditNetworkSecurity },
      { name: 'Storage Security Audit', fn: this.auditStorageSecurity },
      { name: 'Message Passing Security', fn: this.auditMessagePassingSecurity },
      { name: 'Content Script Security', fn: this.auditContentScriptSecurity },
      { name: 'Background Script Security', fn: this.auditBackgroundScriptSecurity },
      { name: 'API Security Audit', fn: this.auditAPISecurity },
      { name: 'Configuration Security', fn: this.auditConfigurationSecurity },
      { name: 'Dependency Security', fn: this.auditDependencySecurity },
    ];

    for (const audit of audits) {
      try {
        console.log(`\nðŸ” Auditing: ${audit.name}`);
        const result = await audit.fn.call(this);
        this.auditResults.push({
          name: audit.name,
          status: 'SECURE',
          result,
          timestamp: new Date().toISOString(),
        });
        console.log(`âœ… ${audit.name}: SECURE`);
      } catch (error) {
        this.auditResults.push({
          name: audit.name,
          status: 'VULNERABLE',
          error: error.message,
          timestamp: new Date().toISOString(),
        });
        console.error(`âŒ ${audit.name}: VULNERABLE - ${error.message}`);
      }
    }

    this.generateSecurityReport();
  }

  /**
   * Audit XSS vulnerabilities
   */
  async auditXSSVulnerabilities() {
    const fs = require('fs');
    const sourceFiles = [
      'src/service-worker.js',
      'src/content.js',
      'src/popup.js',
      'src/options.js',
      'src/gateway.js',
    ];

    const xssVulnerabilities = [];

    for (const file of sourceFiles) {
      if (!fs.existsSync(file)) {continue;}

      const content = fs.readFileSync(file, 'utf8');

      // Check for dangerous patterns
      const dangerousPatterns = [
        { pattern: /innerHTML\s*=/, message: 'innerHTML assignment - XSS risk' },
        { pattern: /outerHTML\s*=/, message: 'outerHTML assignment - XSS risk' },
        { pattern: /document\.write/, message: 'document.write - XSS risk' },
        { pattern: /eval\s*\(/, message: 'eval() usage - Code injection risk' },
        { pattern: /Function\s*\(/, message: 'Function constructor - Code injection risk' },
        {
          pattern: /setTimeout\s*\(\s*["']/,
          message: 'String-based setTimeout - Code injection risk',
        },
        {
          pattern: /setInterval\s*\(\s*["']/,
          message: 'String-based setInterval - Code injection risk',
        },
      ];

      for (const { pattern, message } of dangerousPatterns) {
        const matches = content.match(pattern);
        if (matches) {
          xssVulnerabilities.push({
            file,
            vulnerability: message,
            count: matches.length,
            severity: 'HIGH',
          });
        }
      }

      // Check for safe alternatives
      const safePatterns = [
        { pattern: /textContent\s*=/, message: 'Safe textContent usage' },
        { pattern: /createTextNode/, message: 'Safe createTextNode usage' },
        { pattern: /createElement/, message: 'Safe createElement usage' },
      ];

      for (const { pattern, message } of safePatterns) {
        const matches = content.match(pattern);
        if (matches) {
          console.log(`  âœ… ${file}: ${message} (${matches.length} instances)`);
        }
      }
    }

    if (xssVulnerabilities.length > 0) {
      throw new Error(`XSS vulnerabilities found: ${xssVulnerabilities.length} issues`);
    }

    return {
      vulnerabilities: xssVulnerabilities,
      status: 'SECURE',
    };
  }

  /**
   * Audit injection attacks
   */
  async auditInjectionAttacks() {
    const fs = require('fs');
    const sourceFiles = [
      // Support both legacy and current service worker filenames
      'src/service-worker.js',
      'src/service_worker.js',
      'src/content.js',
      'src/gateway.js',
      'src/options.js',
    ];

    const injectionVulnerabilities = [];

    for (const file of sourceFiles) {
      if (!fs.existsSync(file)) {continue;}

      const content = fs.readFileSync(file, 'utf8');

      // Check for SQL injection patterns (if any database queries)
      // Use word boundaries to avoid false positives from constants like UPDATE_CENTRAL_CONFIG.
      // Only match UPPERCASE SQL keywords to avoid triggering on regular text like "select".
      const sqlPatterns = content.match(/\b(SELECT|INSERT|UPDATE|DELETE)\b/g);
      if (sqlPatterns) {
        injectionVulnerabilities.push({
          file,
          vulnerability: 'Potential SQL injection risk',
          severity: 'HIGH',
        });
      }

      // Check for command injection (Node/OS-level command execution)
      // Avoid false positives from DOM APIs like document.execCommand or CSS font names (system-ui).
      const commandInjectionPatterns = [
        /child_process\.exec\s*\(/,
        /child_process\.spawn\s*\(/,
        /execFile\s*\(/,
        /system\s*\(/,
      ];
      const hasCommandInjection = commandInjectionPatterns.some((pattern) => pattern.test(content));
      if (hasCommandInjection) {
        injectionVulnerabilities.push({
          file,
          vulnerability: 'Potential command injection risk',
          severity: 'CRITICAL',
        });
      }

      // Check for template injection
      if (content.includes('${') && content.includes('`')) {
        const templatePatterns = content.match(/\$\{[^}]+\}/g);
        if (templatePatterns) {
          // Check if user input is used in templates
          if (content.includes('userInput') || content.includes('userData')) {
            injectionVulnerabilities.push({
              file,
              vulnerability: 'Potential template injection risk',
              severity: 'MEDIUM',
            });
          }
        }
      }
    }

    if (injectionVulnerabilities.length > 0) {
      const details = injectionVulnerabilities
        .map((v) => `${v.file}: ${v.vulnerability}`)
        .join('; ');
      throw new Error(
        `Injection vulnerabilities found: ${injectionVulnerabilities.length} issues (${details})`
      );
    }

    return {
      vulnerabilities: injectionVulnerabilities,
      status: 'SECURE',
    };
  }

  /**
   * Audit data exposure
   */
  async auditDataExposure() {
    const fs = require('fs');
    const sourceFiles = [
      // Support both legacy and current service worker filenames
      'src/service-worker.js',
      'src/service_worker.js',
      'src/content.js',
      'src/gateway.js',
      'src/options.js',
    ];

    const dataExposureIssues = [];

    for (const file of sourceFiles) {
      if (!fs.existsSync(file)) {continue;}

      const content = fs.readFileSync(file, 'utf8');
      const lines = content.split('\n');

      // Check for sensitive data in console logs (same line heuristic to reduce false positives)
      const hasPasswordLogging = lines.some(
        (line) => line.includes('console.log') && line.toLowerCase().includes('password')
      );
      if (hasPasswordLogging) {
        dataExposureIssues.push({
          file,
          issue: 'Potential password logging',
          severity: 'HIGH',
        });
      }

      const hasTokenLogging = lines.some(
        (line) => line.includes('console.log') && line.toLowerCase().includes('token')
      );
      if (hasTokenLogging) {
        dataExposureIssues.push({
          file,
          issue: 'Potential token logging',
          severity: 'HIGH',
        });
      }

      const hasApiKeyLogging = lines.some(
        (line) => line.includes('console.log') && line.toLowerCase().includes('apikey')
      );
      if (hasApiKeyLogging) {
        dataExposureIssues.push({
          file,
          issue: 'Potential API key logging',
          severity: 'CRITICAL',
        });
      }

      // Check for localStorage with sensitive data
      if (
        content.includes('localStorage') &&
        (content.toLowerCase().includes('password') || content.toLowerCase().includes('token'))
      ) {
        dataExposureIssues.push({
          file,
          issue: 'Sensitive data in localStorage',
          severity: 'MEDIUM',
        });
      }

      // Check for URL parameters with sensitive data
      if (content.includes('window.location') && content.toLowerCase().includes('password')) {
        dataExposureIssues.push({
          file,
          issue: 'Sensitive data in URL parameters',
          severity: 'HIGH',
        });
      }
    }

    if (dataExposureIssues.length > 0) {
      throw new Error(`Data exposure issues found: ${dataExposureIssues.length} issues`);
    }

    return {
      issues: dataExposureIssues,
      status: 'SECURE',
    };
  }

  /**
   * Audit permission abuse
   */
  async auditPermissionAbuse() {
    const fs = require('fs');
    const manifest = JSON.parse(fs.readFileSync('manifest.json', 'utf8'));

    const permissionIssues = [];

    // Check for overly broad permissions
    if (manifest.permissions.includes('<all_urls>')) {
      permissionIssues.push({
        permission: '<all_urls>',
        issue: 'Overly broad host permission',
        severity: 'MEDIUM',
        recommendation: 'Use specific host permissions instead',
      });
    }

    if (manifest.permissions.includes('tabs')) {
      permissionIssues.push({
        permission: 'tabs',
        issue: 'Access to all tabs',
        severity: 'MEDIUM',
        recommendation: 'Use activeTab permission if possible',
      });
    }

    // Check for unnecessary permissions
    const requiredPermissions = ['storage', 'alarms'];
    const unnecessaryPermissions = manifest.permissions.filter(
      (perm) => !requiredPermissions.includes(perm)
    );

    if (unnecessaryPermissions.length > 0) {
      permissionIssues.push({
        permissions: unnecessaryPermissions,
        issue: 'Potentially unnecessary permissions',
        severity: 'LOW',
        recommendation: 'Review if these permissions are actually needed',
      });
    }

    // Check for permission usage in code
    const sourceFiles = ['src/service-worker.js', 'src/content.js', 'src/options.js'];
    const permissionUsage = {};

    for (const file of sourceFiles) {
      if (!fs.existsSync(file)) {continue;}

      const content = fs.readFileSync(file, 'utf8');

      // Check for chrome API usage
      const chromeAPIs = content.match(/chrome\.(\w+)\./g) || [];
      chromeAPIs.forEach((api) => {
        const domain = api.split('.')[1];
        permissionUsage[domain] = (permissionUsage[domain] || 0) + 1;
      });
    }

    // Check if declared permissions match usage
    const declaredPermissions = manifest.permissions;
    const usedPermissions = Object.keys(permissionUsage);

    const unusedPermissions = declaredPermissions.filter((perm) => !usedPermissions.includes(perm));
    if (unusedPermissions.length > 0) {
      permissionIssues.push({
        permissions: unusedPermissions,
        issue: 'Declared but unused permissions',
        severity: 'LOW',
        recommendation: 'Remove unused permissions',
      });
    }

    return {
      issues: permissionIssues,
      permissionUsage,
      status: 'REVIEW_NEEDED',
    };
  }

  /**
   * Audit network security
   */
  async auditNetworkSecurity() {
    const fs = require('fs');
    const sourceFiles = ['src/gateway.js', 'src/service-worker.js'];

    const networkIssues = [];

    for (const file of sourceFiles) {
      if (!fs.existsSync(file)) {continue;}

      const content = fs.readFileSync(file, 'utf8');

      // Check for HTTP usage (should use HTTPS)
      if (content.includes('http://') && !content.includes('localhost')) {
        networkIssues.push({
          file,
          issue: 'HTTP usage detected',
          severity: 'HIGH',
          recommendation: 'Use HTTPS for all external requests',
        });
      }

      // Check for fetch without proper error handling
      if (content.includes('fetch(') && !content.includes('try {')) {
        networkIssues.push({
          file,
          issue: 'fetch() without error handling',
          severity: 'MEDIUM',
          recommendation: 'Add proper error handling for network requests',
        });
      }

      // Check for hardcoded URLs
      const urlPattern = /https?:\/\/[^\s"']+/g;
      const urls = content.match(urlPattern) || [];
      const hardcodedUrls = urls.filter(
        (url) => !url.includes('localhost') && !url.includes('127.0.0.1')
      );

      if (hardcodedUrls.length > 0) {
        networkIssues.push({
          file,
          issue: 'Hardcoded URLs detected',
          severity: 'LOW',
          recommendation: 'Use configuration for URLs',
          urls: hardcodedUrls,
        });
      }

      // Check for CORS issues
      if (
        content.includes('fetch(') &&
        !content.includes('mode:') &&
        !content.includes('credentials:')
      ) {
        networkIssues.push({
          file,
          issue: 'fetch() without CORS configuration',
          severity: 'LOW',
          recommendation: 'Configure CORS properly for cross-origin requests',
        });
      }
    }

    return {
      issues: networkIssues,
      status: networkIssues.length === 0 ? 'SECURE' : 'REVIEW_NEEDED',
    };
  }

  /**
   * Audit storage security
   */
  async auditStorageSecurity() {
    const fs = require('fs');
    const sourceFiles = ['src/service-worker.js', 'src/options.js'];

    const storageIssues = [];

    for (const file of sourceFiles) {
      if (!fs.existsSync(file)) {continue;}

      const content = fs.readFileSync(file, 'utf8');

      // Check for sensitive data in storage
      if (
        content.includes('chrome.storage') &&
        (content.includes('password') || content.includes('token'))
      ) {
        storageIssues.push({
          file,
          issue: 'Sensitive data in Chrome storage',
          severity: 'HIGH',
          recommendation: 'Encrypt sensitive data before storage',
        });
      }

      // Check for localStorage usage (less secure than chrome.storage)
      if (content.includes('localStorage')) {
        storageIssues.push({
          file,
          issue: 'localStorage usage detected',
          severity: 'MEDIUM',
          recommendation: 'Use chrome.storage instead of localStorage',
        });
      }

      // Check for sessionStorage usage
      if (content.includes('sessionStorage')) {
        storageIssues.push({
          file,
          issue: 'sessionStorage usage detected',
          severity: 'LOW',
          recommendation: 'Consider using chrome.storage for persistence',
        });
      }

      // Check for proper error handling in storage operations
      if (content.includes('chrome.storage') && !content.includes('chrome.runtime.lastError')) {
        storageIssues.push({
          file,
          issue: 'Storage operations without error handling',
          severity: 'MEDIUM',
          recommendation: 'Add error handling for storage operations',
        });
      }
    }

    return {
      issues: storageIssues,
      status: storageIssues.length === 0 ? 'SECURE' : 'REVIEW_NEEDED',
    };
  }

  /**
   * Audit message passing security
   */
  async auditMessagePassingSecurity() {
    const fs = require('fs');
    const sourceFiles = ['src/service-worker.js', 'src/content.js'];

    const messageIssues = [];

    for (const file of sourceFiles) {
      if (!fs.existsSync(file)) {continue;}

      const content = fs.readFileSync(file, 'utf8');

      // Check for origin validation in message handlers
      if (content.includes('chrome.runtime.onMessage') && !content.includes('sender.origin')) {
        messageIssues.push({
          file,
          issue: 'Message handler without origin validation',
          severity: 'MEDIUM',
          recommendation: 'Validate message sender origin',
        });
      }

      // Check for message validation
      if (content.includes('chrome.runtime.onMessage') && !content.includes('typeof')) {
        messageIssues.push({
          file,
          issue: 'Message handler without message validation',
          severity: 'MEDIUM',
          recommendation: 'Validate message structure and content',
        });
      }

      // Check for postMessage usage
      if (content.includes('postMessage') && !content.includes('event.origin')) {
        messageIssues.push({
          file,
          issue: 'postMessage without origin validation',
          severity: 'HIGH',
          recommendation: 'Validate event.origin in postMessage handlers',
        });
      }

      // Check for window.postMessage
      if (content.includes('window.postMessage')) {
        messageIssues.push({
          file,
          issue: 'window.postMessage usage',
          severity: 'MEDIUM',
          recommendation: 'Use chrome.runtime.sendMessage instead',
        });
      }
    }

    return {
      issues: messageIssues,
      status: messageIssues.length === 0 ? 'SECURE' : 'REVIEW_NEEDED',
    };
  }

  /**
   * Audit content script security
   */
  async auditContentScriptSecurity() {
    const fs = require('fs');
    const contentScript = fs.readFileSync('src/content.js', 'utf8');

    const contentIssues = [];

    // Check for DOM access patterns
    if (contentScript.includes('document.') && !contentScript.includes('try {')) {
      contentIssues.push({
        issue: 'DOM access without error handling',
        severity: 'LOW',
        recommendation: 'Add error handling for DOM operations',
      });
    }

    // Check for global variable pollution
    if (contentScript.includes('window.') && contentScript.includes('=')) {
      contentIssues.push({
        issue: 'Potential global variable pollution',
        severity: 'LOW',
        recommendation: 'Use namespaced variables',
      });
    }

    // Check for event listener cleanup
    if (
      contentScript.includes('addEventListener') &&
      !contentScript.includes('removeEventListener')
    ) {
      contentIssues.push({
        issue: 'Event listeners without cleanup',
        severity: 'MEDIUM',
        recommendation: 'Add event listener cleanup',
      });
    }

    // Check for secure communication with background
    if (
      contentScript.includes('chrome.runtime.sendMessage') &&
      !contentScript.includes('response')
    ) {
      contentIssues.push({
        issue: 'Message sending without response handling',
        severity: 'LOW',
        recommendation: 'Handle message responses properly',
      });
    }

    return {
      issues: contentIssues,
      status: contentIssues.length === 0 ? 'SECURE' : 'REVIEW_NEEDED',
    };
  }

  /**
   * Audit background script security
   */
  async auditBackgroundScriptSecurity() {
    const fs = require('fs');
    const backgroundScript = fs.readFileSync('src/service-worker.js', 'utf8');

    const backgroundIssues = [];

    // Check for persistent storage
    if (
      backgroundScript.includes('chrome.storage.local') &&
      backgroundScript.includes('sensitive')
    ) {
      backgroundIssues.push({
        issue: 'Sensitive data in persistent storage',
        severity: 'HIGH',
        recommendation: 'Encrypt sensitive data before storage',
      });
    }

    // Check for external requests
    if (backgroundScript.includes('fetch(') && !backgroundScript.includes('https://')) {
      backgroundIssues.push({
        issue: 'HTTP requests in background script',
        severity: 'HIGH',
        recommendation: 'Use HTTPS for all external requests',
      });
    }

    // Check for proper error handling
    if (
      backgroundScript.includes('chrome.runtime.onMessage') &&
      !backgroundScript.includes('try {')
    ) {
      backgroundIssues.push({
        issue: 'Message handler without error handling',
        severity: 'MEDIUM',
        recommendation: 'Add error handling for message handlers',
      });
    }

    return {
      issues: backgroundIssues,
      status: backgroundIssues.length === 0 ? 'SECURE' : 'REVIEW_NEEDED',
    };
  }

  /**
   * Audit API security
   */
  async auditAPISecurity() {
    const fs = require('fs');
    const gatewayScript = fs.readFileSync('src/gateway.js', 'utf8');

    const apiIssues = [];

    // Check for API key exposure
    if (gatewayScript.includes('apiKey') && gatewayScript.includes('console.log')) {
      apiIssues.push({
        issue: 'Potential API key logging',
        severity: 'CRITICAL',
        recommendation: 'Never log API keys or sensitive credentials',
      });
    }

    // Check for request validation
    if (gatewayScript.includes('fetch(') && !gatewayScript.includes('JSON.stringify')) {
      apiIssues.push({
        issue: 'API requests without proper serialization',
        severity: 'MEDIUM',
        recommendation: 'Validate and serialize request data properly',
      });
    }

    // Check for response validation
    if (gatewayScript.includes('response.json()') && !gatewayScript.includes('try {')) {
      apiIssues.push({
        issue: 'Response parsing without error handling',
        severity: 'MEDIUM',
        recommendation: 'Add error handling for response parsing',
      });
    }

    // Check for timeout handling
    if (gatewayScript.includes('fetch(') && !gatewayScript.includes('timeout')) {
      apiIssues.push({
        issue: 'API requests without timeout',
        severity: 'LOW',
        recommendation: 'Add timeout handling for API requests',
      });
    }

    return {
      issues: apiIssues,
      status: apiIssues.length === 0 ? 'SECURE' : 'REVIEW_NEEDED',
    };
  }

  /**
   * Audit configuration security
   */
  async auditConfigurationSecurity() {
    const fs = require('fs');
    const manifest = JSON.parse(fs.readFileSync('manifest.json', 'utf8'));

    const configIssues = [];

    // Check for CSP configuration
    if (!manifest.content_security_policy) {
      configIssues.push({
        issue: 'No Content Security Policy defined',
        severity: 'MEDIUM',
        recommendation: 'Add CSP to prevent XSS attacks',
      });
    }

    // Check for web accessible resources
    if (manifest.web_accessible_resources) {
      configIssues.push({
        issue: 'Web accessible resources defined',
        severity: 'LOW',
        recommendation: 'Review if web accessible resources are necessary',
      });
    }

    // Check for externally_connectable
    if (manifest.externally_connectable) {
      configIssues.push({
        issue: 'External connections allowed',
        severity: 'HIGH',
        recommendation: 'Review external connection requirements',
      });
    }

    return {
      issues: configIssues,
      status: configIssues.length === 0 ? 'SECURE' : 'REVIEW_NEEDED',
    };
  }

  /**
   * Audit dependency security
   */
  async auditDependencySecurity() {
    // Check for package.json (if exists)
    const fs = require('fs');
    const dependencyIssues = [];

    if (fs.existsSync('package.json')) {
      const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));

      // Check for known vulnerable packages
      const vulnerablePackages = ['jquery@1.x', 'lodash@4.x', 'moment@2.x'];

      const dependencies = { ...packageJson.dependencies, ...packageJson.devDependencies };

      for (const [packageName, version] of Object.entries(dependencies)) {
        if (vulnerablePackages.includes(`${packageName}@${version}`)) {
          dependencyIssues.push({
            package: packageName,
            version: version,
            issue: 'Known vulnerable package',
            severity: 'HIGH',
            recommendation: 'Update to latest secure version',
          });
        }
      }
    }

    return {
      issues: dependencyIssues,
      status: dependencyIssues.length === 0 ? 'SECURE' : 'REVIEW_NEEDED',
    };
  }

  /**
   * Generate security report
   */
  generateSecurityReport() {
    const totalAudits = this.auditResults.length;
    const secureAudits = this.auditResults.filter((a) => a.status === 'SECURE').length;
    const vulnerableAudits = this.auditResults.filter((a) => a.status === 'VULNERABLE').length;
    const reviewNeededAudits = this.auditResults.filter((a) => a.status === 'REVIEW_NEEDED').length;

    const securityScore = (secureAudits / totalAudits) * 100;

    const report = {
      summary: {
        totalAudits,
        secureAudits,
        vulnerableAudits,
        reviewNeededAudits,
        securityScore: Math.round(securityScore * 100) / 100,
        status:
          securityScore >= 90 ? 'SECURE' : securityScore >= 70 ? 'NEEDS_IMPROVEMENT' : 'VULNERABLE',
      },
      results: this.auditResults,
      recommendations: this.generateSecurityRecommendations(),
      timestamp: new Date().toISOString(),
    };

    console.log('\n' + '='.repeat(60));
    console.log('ðŸ”’ SECURITY VULNERABILITY AUDIT REPORT');
    console.log('='.repeat(60));
    console.log(`Total Audits: ${totalAudits}`);
    console.log(`Secure: ${secureAudits}`);
    console.log(`Vulnerable: ${vulnerableAudits}`);
    console.log(`Review Needed: ${reviewNeededAudits}`);
    console.log(`Security Score: ${securityScore.toFixed(2)}%`);
    console.log(`Status: ${report.summary.status}`);

    if (securityScore >= 90) {
      console.log('\nâœ… EXTENSION IS SECURE');
    } else if (securityScore >= 70) {
      console.log('\nâš ï¸ EXTENSION NEEDS SECURITY IMPROVEMENTS');
    } else {
      console.log('\nâŒ EXTENSION HAS SECURITY VULNERABILITIES');
    }

    console.log('\nðŸ’¡ SECURITY RECOMMENDATIONS:');
    report.recommendations.forEach((rec) => {
      console.log(`  - ${rec}`);
    });

    // Save report
    const fs = require('fs');
    fs.writeFileSync('security-vulnerability-audit-report.json', JSON.stringify(report, null, 2));
    console.log('\nðŸ“„ Detailed report saved to: security-vulnerability-audit-report.json');

    return report;
  }

  /**
   * Generate security recommendations
   */
  generateSecurityRecommendations() {
    const recommendations = [];

    const vulnerableAudits = this.auditResults.filter((a) => a.status === 'VULNERABLE');
    const reviewNeededAudits = this.auditResults.filter((a) => a.status === 'REVIEW_NEEDED');

    if (vulnerableAudits.length > 0) {
      recommendations.push('Address critical security vulnerabilities immediately');
    }

    if (reviewNeededAudits.length > 0) {
      recommendations.push('Review and improve security practices');
    }

    recommendations.push('Implement Content Security Policy');
    recommendations.push('Use HTTPS for all external requests');
    recommendations.push('Validate all user inputs');
    recommendations.push('Encrypt sensitive data before storage');
    recommendations.push('Add proper error handling throughout');
    recommendations.push('Regular security audits and updates');
    recommendations.push('Follow OWASP security guidelines');

    return recommendations;
  }
}

// Run security audit if this script is executed directly
if (require.main === module) {
  const auditor = new SecurityVulnerabilityAudit();
  auditor.runSecurityAudit().catch(console.error);
}

module.exports = SecurityVulnerabilityAudit;
